# 笔记部分

1. 为什么实验中创建的用户态线程需要复制内核态页表内容？
  如果该用户态线程发起了系统调用，需要由操作系统完成一部分工作，由于整个过程，执行的上下文没有变化，需要用户态线程中记录核心态内存信息。

2. 本实验验证部分存在问题，未解决。

# 习题部分

## 练习1

1. 请在实验报告中描述当创建一个用户态进程并加载了应用程序后,CPU是如
  何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行(RUNNING态)到具体执行应用程序第一条指令的整个经过。

  关于内核idle进程如何切换到下一条线程的过程，查看上一个实验的记录。

  lab4中，能够实现让新线程执行特定函数--init_main，本次实验从这里开始。

  总体路径如下：
  init_main --> （do_wait --> shedule) --> usermain --> KERNEL_EXECVE --> kernel_execve --> ... --> do_execve --> load_icode


  init_main 以自己为模板，创建user_main为入口的新内核线程，

  中间两个函数调用，保证了新创建的子线程将被执行。

  user_main是每个用户程序执行的入口，usermain将调用KERNEL_EXECVE

  KERNEL_EXECVE开始处理ucore事先加载好的ELF制式程序，将这些信息送入kernel_execve开始执行

  kernel_execve进一步封装好信息，发起系统中断，并在中断结束后，将结果返回

  do_execve将开始对线程的内存进行检查和清除(mm必须为null)，并调用load_icode根据ELF中的信息，设置相应的段，分配好相应的存储，修改tf后返回

  至此，一个内核线程，变成了加载特定程序的用户态进程

  等到上述过程执行完成，将返回到之前的系统调用（kernel_execve），通过最后的iret指令，完成最后的切换。



## 练习2


1. 如何设计实现”Copy on Write 机制“（TODO:BLOG)


## 练习3

1. 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？
  修改proc里的状态位，对进程链表进行更新。

2. 请给出ucore中一个用户态进程的执行状态生命周期图
  见笔记。




























END
